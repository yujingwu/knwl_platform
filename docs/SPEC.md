# Step 2 SPEC — Simplified Knowledge Indexing Service (FastAPI + SQLite FTS5)

## Purpose
This spec is the single source of truth for **Part 2: Core Implementation** of the coding assessment: implement a simplified knowledge indexing service with 3 features (ingest, search, health/metrics) using an embedded database or in-memory storage.

## Goals
- **Ingest** documents per tenant
- **Text-based search** per tenant with ranked results and pagination
- **Health** endpoint
- **Metrics** endpoint with per-tenant breakdowns
- **Auth middleware**: API-key based; validates tenant authorization
- Embedded storage: **SQLite** with **FTS5** for indexing/search
- Tests: unit + integration, **>70% coverage**
- Performance: search **p95 < 100ms** at **10,000 docs** (include benchmark script)
- OpenAPI/Swagger available from FastAPI
- Clear setup instructions + curl examples in `README.md`

## Non-goals
- Semantic search / embeddings (belongs to Part 1 design)
- Queues/object store/async pipeline (Part 1 concepts only)

## Stack (Part 2)
- Python 3.x
- FastAPI + Pydantic
- SQLite file DB + FTS5 virtual table
- pytest + pytest-cov
- Optional: Docker (not required for Step 2, but OK)

## Configuration (env vars)
- `DB_PATH` default `./data/app.db`
- `API_KEYS_JSON` JSON string mapping API key -> list of tenant IDs (required for local dev)
  - Example: `{"key_admin":["t1","t2"],"key_t1":["t1"]}`
- `MAX_TITLE_LEN` default `200`
- `MAX_CONTENT_LEN` default `200000`
- `MAX_TAGS` default `20`
- `LOG_LEVEL` default `INFO`

**Implementation note:** Implement all defaults above; each value must be overridable via environment variables at runtime.

## Auth model
- Header: `X-API-Key: <key>`
- Missing/invalid key -> `401`
- Valid key but tenant not allowed -> `403`
- Tenant comes from path param `{tenantId}` and is validated against the API key’s allowed tenants.

## Data model
### documents table
- `tenant_id TEXT NOT NULL`
- `document_id TEXT NOT NULL` (UUID/ULID)
- `title TEXT NOT NULL`
- `content TEXT NOT NULL`
- `tags TEXT NOT NULL` (JSON array string)
- `created_at TEXT NOT NULL` (ISO8601)
- `updated_at TEXT NOT NULL` (ISO8601)
- Primary key: `(tenant_id, document_id)`
- Index: `idx_documents_tenant_created (tenant_id, created_at DESC)`


```sql
-- Base table
CREATE TABLE IF NOT EXISTS documents (
  tenant_id   TEXT NOT NULL,
  document_id TEXT NOT NULL,
  title       TEXT NOT NULL,
  content     TEXT NOT NULL,
  tags        TEXT NOT NULL, -- JSON array string
  created_at  TEXT NOT NULL, -- ISO8601
  updated_at  TEXT NOT NULL, -- ISO8601
  PRIMARY KEY (tenant_id, document_id)
);

CREATE INDEX IF NOT EXISTS idx_documents_tenant_created
ON documents(tenant_id, created_at DESC);
```

### documents_fts virtual table (FTS5 external content)
- Includes: `tenant_id UNINDEXED`, `title`, `content`, `tags`
- Maintained with triggers on insert/update/delete

```sql
-- External-content FTS5 table (links to documents via rowid)
CREATE VIRTUAL TABLE IF NOT EXISTS documents_fts USING fts5(
  tenant_id UNINDEXED,
  title,
  content,
  tags,
  content='documents',
  content_rowid='rowid'
);

-- Triggers to keep FTS in sync
CREATE TRIGGER IF NOT EXISTS documents_ai AFTER INSERT ON documents BEGIN
  INSERT INTO documents_fts(rowid, tenant_id, title, content, tags)
  VALUES (new.rowid, new.tenant_id, new.title, new.content, new.tags);
END;

CREATE TRIGGER IF NOT EXISTS documents_ad AFTER DELETE ON documents BEGIN
  INSERT INTO documents_fts(documents_fts, rowid, tenant_id, title, content, tags)
  VALUES('delete', old.rowid, old.tenant_id, old.title, old.content, old.tags);
END;

CREATE TRIGGER IF NOT EXISTS documents_au AFTER UPDATE ON documents BEGIN
  INSERT INTO documents_fts(documents_fts, rowid, tenant_id, title, content, tags)
  VALUES('delete', old.rowid, old.tenant_id, old.title, old.content, old.tags);
  INSERT INTO documents_fts(rowid, tenant_id, title, content, tags)
  VALUES (new.rowid, new.tenant_id, new.title, new.content, new.tags);
END;
```


### Search semantics

- Search is **tenant-scoped** and uses SQLite **FTS5** with `MATCH`.
- Return results ranked by relevance using `bm25(documents_fts)`.
- The API must return a numeric `score` where **higher = more relevant**:
  - If `bm25()` in your SQLite build is smaller-is-better, transform before returning: `score = 1.0 / (1.0 + bm25_raw)`.
- Include a highlighted `snippet` generated by SQLite `snippet()`.

#### Search query (results)
```sql
SELECT d.document_id,
       d.title,
       d.tags,
       d.created_at,
       snippet(documents_fts, 2, '<b>', '</b>', '...', 10) AS snippet,
       bm25(documents_fts) AS score
FROM documents_fts
JOIN documents d ON d.rowid = documents_fts.rowid
WHERE documents_fts.tenant_id = ?
  AND documents_fts MATCH ?
ORDER BY score
LIMIT ? OFFSET ?;
```

#### Total count query (for pagination)
```sql
SELECT COUNT(*)
FROM documents_fts
WHERE tenant_id = ?
  AND documents_fts MATCH ?;
```

#### Notes

- Bind params correspond to: `(tenant_id, query, limit, offset)` for the results query, and `(tenant_id, query)` for the count query.
- Pagination: `limit` default **10** (max **50**), `offset` default **0**.
- `total` in the API response comes from the count query above (acceptable for the 10K-doc benchmark target).



## Observability requirements
- Generate/propagate `X-Request-Id`:
  - Use client-provided header if present, else generate UUID.
- Structured logs per request: request_id, tenant_id (if available), method, path, status, latency_ms.

## Benchmark
Create `scripts/benchmark.py`:
- Populate 10,000 docs for one tenant
- Warm up ~20 queries
- Measure p50/p95 for search endpoint across 200–1000 queries
- Print results; assert p95 < 100ms (configurable threshold)
- Use either in-process `TestClient` or `httpx` against a running server; document approach in README.

## Tests (pytest)

### Required unit tests
- **Auth middleware**
  - Missing/invalid API key returns `401`
  - Valid API key but tenant not authorized returns `403`
- **Validation**
  - Invalid request body returns `400` (e.g., missing title/content, over max length, invalid tags)
- **Search ranking**
  - Search returns non-empty results after ingest
  - Results are returned in **descending** order of relevance score (higher is better)

### Required integration tests
- **Ingest → search**
  - Ingest a document, then search for a term in the content returns that document
- **Multi-tenant isolation**
  - Ingest docs into tenant A and tenant B; searching tenant A must never return tenant B docs
- **Metrics correctness**
  - After making API calls, `/metrics` reflects incremented request counters and error counters (where applicable)

### Coverage
- Use `pytest-cov` and ensure coverage is **> 0.70** (e.g., `pytest --cov=app --cov-report=term-missing`).

## Repo structure (recommended)
```
repo/
  app/
    __init__.py
    main.py
    api/
      routes_docs.py
      routes_search.py
      routes_health.py
      routes_metrics.py
    core/
      config.py
      auth.py
      metrics.py
      logging.py
    db/
      sqlite.py
      schema.py
      repo.py
    models/
      schemas.py
  scripts/
    benchmark.py
  tests/
    test_auth.py
    test_ingest.py
    test_search.py
    test_metrics.py
  requirements.txt (or pyproject.toml)
  README.md
  docs/
    SPEC.md
    API.md
    DESIGN.md
    DECISIONS.md
```
## README checklist

The repository `README.md` must include:

### Local setup
- Create and activate a virtualenv
- Install dependencies
- Set `API_KEYS_JSON` (include a working example)
- Initialize/create the SQLite DB (if needed)
- Run the server (command + expected port)

### Example usage (curl)
- Ingest a document (include headers + JSON body)
- Search documents (include query params)
- Health endpoint
- Metrics endpoint

### Testing
- How to run tests
- How to run coverage and verify **> 70%** coverage

### Benchmark
- How to run the benchmark script
- What output to expect (p50/p95) and how to interpret pass/fail
## Acceptance checklist
- [ ] Ingest returns `201` with `documentId`
- [ ] Search returns ranked results with `score` and `snippet`
- [ ] Tenant isolation is enforced (no cross-tenant leakage)
- [ ] `/health` returns 200 ok
- [ ] `/metrics` returns JSON with required counters (see API.md)
- [ ] Tests pass; coverage > 70%
- [ ] Benchmark demonstrates p95 < 100ms @ 10K docs
- [ ] README includes setup + curl examples + test/benchmark commands
